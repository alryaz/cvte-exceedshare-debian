name: Repackage UOS/Deepin packages

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * *"

env:
  PERMANENT_RELEASE: repository
  REPOSITORY_URL: "https://home-store-packages.uniontech.com/appstore"
  REPOSITORY_DIST: "eagle"
  PACKAGE_NAME: com.cvte.exceedshare

jobs:
  download-lists:
    runs-on: ubuntu-latest
    outputs:
      links: ${{ steps.links.outputs.links }}
    steps:
    - name: Download Release file
      run: |
        # Download the Release file
        curl -fsL -o Release "${{ env.REPOSITORY_URL }}/dists/${{ env.REPOSITORY_DIST }}/Release"
        
    - name: Parse package sources
      run: |
        grep -Eo '[^ ]+/Packages' Release | sort | uniq > Sources
        [ -s "Sources"] && ( echo "Sources not found" >&2; exit 1 )
        echo "Found sources:"
        cat Sources
        
    - name: Download package sources
      run: |
        curl -sL --parallel --parallel-immediate $(sed -e 's!^!${{ env.REPOSITORY_URL }}/dists/${{ env.REPOSITORY_DIST }}/!g' Sources) > Packages

    - name: Store package laths
      id: links
      run: |
        # Capture the output of the grep command
        DEB_LINKS=$(grep -oE '[^ ]+${{ env.PACKAGE_NAME }}[^ ]+\.deb' Packages)

        # Convert the output to a JSON array
        DEB_LINKS_JSON=$(echo "$DEB_LINKS" | jq -R -s -c 'split("\n") | map(select(length > 0))')

        # Set the output
        echo "links=$DEB_LINKS_JSON" >> $GITHUB_OUTPUT

  handle-package:
    runs-on: ubuntu-latest
    needs: download-lists
    strategy:
      matrix:
        link: ${{ fromJSON(needs.download-lists.outputs.links) }}
    steps:
    - name: Store outputs
      id: vars
      run: |
        file="$(basename "${{ matrix.link }}")"
        version="$(echo "${file}" | cut -d'_' -f2)"
        (
          echo "file='${file}'"
          echo "version='${version}'"
          echo "tag='${{ env.PACKAGE_NAME }}-v${version}'"
          echo "latest='${file/_${version}_/_latest_}'"
        ) >> $GITHUB_OUTPUT

    - name: Check if release upload already exists
      if: ${{ github.event_name != 'workflow_dispatch' }}
      id: exists
      run: |
        check_exists() {
          url="${{ github.server_url }}/${{ github.repository }}/releases/download/$1"
          echo "$2_url='${url}'" >> $GITHUB_OUTPUT
          echo $1=((curl -sIL --fail-with-body "${url}" && curl -sIL --fail-with-body "${url}.sha256") &&
          ( echo true ) || ( echo false )) >> $GITHUB_OUTPUT
        }

        check_exists "${{ steps.vars.outputs.tag }}/${{ steps.vars.outputs.file }}" "version"
        check_exists "${{ env.PERMANENT_RELEASE }}/${{ steps.vars.outputs.latest }}" "latest"

    - name: Rebuild package
      id: rebuild
      if: ${{ github.event_name == 'workflow_dispatch' || steps.exists.outputs.version == 'false' }}
      run: |
        # Download package
        curl -sL -o "${{ steps.vars.outputs.file }}" "${{ env.REPOSITORY_URL }}/${{ matrix.link }}"

        # Extract package contents to temporary directory
        mkdir -p unpacked
        dpkg-deb -x "${{ steps.vars.outputs.file }}" unpacked
        dpkg-deb --control "${{ steps.vars.outputs.file }}" "unpacked/DEBIAN"
        
        # Remove obscure dependency
        sed -i '/deepin-elf-verify/d' "unpacked/DEBIAN/control"
        
        # Make desktop shortcut and icons
        (
            cd "unpacked/opt/apps/${{ env.PACKAGE_NAME }}/entries"
            find applications icons \
                -type f \
                -exec sh -c 'mkdir -p "unpacked/usr/share/$(dirname "{}")"' \; \
                -exec ln -s "/opt/apps/${{ env.PACKAGE_NAME }}/entries/{}" "unpacked/usr/share/{}" \;
        )
        
        # Check if update-desktop-database trigger is present
        if ! grep -q 'update-desktop-database' "unpacked/DEBIAN/postinst"; then
            echo 'dpkg-trigger update-desktop-database' >> "unpacked/DEBIAN/postinst"
        fi
        
        # Rebuild package
        dpkg -b unpacked "${{ steps.vars.outputs.file }}"

        # Calculate hash
        sha256sum "${{ steps.vars.outputs.file }}" > "${{ steps.vars.outputs.file }}.sha256"

    - name: Delete version files
      if: ${{ steps.rebuild.result != 'skipped' && steps.exists.outputs.version == 'true' }}
      uses: flcdrg/remove-release-asset-action@v1
      env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
          release_id: "${{ steps.vars.outputs.tag }}"
          asset_name: "${{ steps.vars.outputs.file }}*"
      
    - name: Release with version
      if: ${{ github.event_name == 'workflow_dispatch' || steps.exists.outputs.version == 'false' }}
      uses: softprops/action-gh-release@v2
      with:
        tag_name: "${{ steps.vars.outputs.tag }}"
        files: "${{ steps.vars.outputs.file }}*"
        make_latest: false
        prerelease: true

    - name: Download release files
      if: ${{ steps.rebuild.result == 'skipped' }}
      run: |
        url="${{ github.server_url }}/${{ github.repository }}/releases/download/${{ steps.vars.outputs.tag }}/${{ steps.vars.outputs.file }}"
        curl -fLZ -o '${{ steps.vars.outputs.file }}' '${{ steps.vars.outputs.file }}.sha256' "${url}" "${url}.sha256"

    - name: Delete latest files
      if: ${{ steps.rebuild.result != 'skipped' && steps.exists.outputs.latest == 'true' }}
      uses: flcdrg/remove-release-asset-action@v1
      env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
          release_id: "${{ steps.vars.outputs.tag }}"
          asset_name: "${{ steps.vars.outputs.file }}*"

    - name: Rename files
      if: ${{ steps.rebuild.result != 'skipped' }}
      run: |
        mv '${{ steps.vars.outputs.file }}' '${{ steps.vars.outputs.latest }}'
        mv '${{ steps.vars.outputs.file }}.sha256' '${{ steps.vars.outputs.file }}.sha256'

    - name: Release with latest
      if: ${{ steps.rebuild.result != 'skipped' }}
      uses: softprops/action-gh-release@v2
      with:
        tag: "${{ env.PERMANENT_RELEASE }}"
        files: "${{ steps.vars.outputs.latest }}*"
        make_latest: true
        prerelease: false
