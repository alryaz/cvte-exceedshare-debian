name: Repackage UOS/Deepin packages

on:
  workflow_dispatch:
    inputs:
      rebuild:
        description: 'Force package rebuild'
        required: false
        type: 'boolean'
        default: 'true'
  schedule:
    - cron: "0 0 * * *"

env:
  PERMANENT_RELEASE: repository
  REPOSITORY_URL: "https://home-store-packages.uniontech.com/appstore"
  REPOSITORY_DIST: "eagle"
  PACKAGE_NAME: com.cvte.exceedshare

jobs:
  download-lists:
    runs-on: ubuntu-latest
    outputs:
      links: ${{ steps.links.outputs.links }}
    steps:
    - name: Download Release file
      uses: nick-fields/retry@v3
      with:
        timeout_minutes: 3
        max_attempts: 3
        command: curl -fL -o Release "${{ env.REPOSITORY_URL }}/dists/${{ env.REPOSITORY_DIST }}/Release"
        
    - name: Parse package sources
      run: |
        grep -Eo '[^ ]+/Packages' Release | sort | uniq > Sources
        [ -s "Sources"] && ( echo "Sources not found" >&2; exit 1 )
        echo "Found sources:"
        cat Sources
        
    - name: Download package sources
      uses: nick-fields/retry@v3
      with:
        timeout_minutes: 3
        max_attempts: 3
        command: curl -L --parallel --parallel-immediate $(sed -e 's!^!${{ env.REPOSITORY_URL }}/dists/${{ env.REPOSITORY_DIST }}/!g' Sources) > Packages

    - name: Store package laths
      id: links
      run: |
        # Capture the output of the grep command
        DEB_LINKS=$(grep -oE '[^ ]+${{ env.PACKAGE_NAME }}[^ ]+\.deb' Packages | sort | uniq)

        # Convert the output to a JSON array
        DEB_LINKS_JSON=$(echo "$DEB_LINKS" | jq -R -s -c 'split("\n") | map(select(length > 0))')

        # Set the output
        echo "links=$DEB_LINKS_JSON" >> $GITHUB_OUTPUT


  handle-package:
    runs-on: ubuntu-latest
    needs: download-lists
    strategy:
      matrix:
        link: ${{ fromJSON(needs.download-lists.outputs.links) }}
      fail-fast: false
    steps:
    - name: Store outputs
      id: vars
      run: |
        file="$(basename "${{ matrix.link }}")"
        version="$(echo "${file}" | rev | cut -d'_' -f2 | rev)"
        (
          echo "file=${file}"
          echo "version=${version}"
          echo "tag=${{ env.PACKAGE_NAME }}-v${version}"
          echo "artifact=file-$(echo "${file}" | sha256sum | cut -d' ' -f1)"
        ) >> $GITHUB_OUTPUT

    - name: Check if release upload already exists
      id: check
      run: |
        url="${{ github.server_url }}/${{ github.repository }}/releases/download/${{ steps.vars.outputs.tag }}/${{ steps.vars.outputs.file }}"
        echo "url=${url}" >> $GITHUB_OUTPUT

        if curl -fLIZ "${url}" "${url}.sha256"; then
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Download package from repository
      if: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.rebuild) || steps.check.outputs.exists == 'false' }}
      id: download
      uses: nick-fields/retry@v3
      with:
        timeout_minutes: 3
        max_attempts: 3
        command: curl -L -o "${{ steps.vars.outputs.file }}" "${{ env.REPOSITORY_URL }}/${{ matrix.link }}"

    - name: Rebuild package
      id: rebuild
      if: ${{ steps.download.result != 'skipped' }}
      run: |
        echo "::group::Extract package contents to a temporary directory"
        mkdir -p unpacked
        dpkg-deb -x "${{ steps.vars.outputs.file }}" unpacked
        dpkg-deb --control "${{ steps.vars.outputs.file }}" "unpacked/DEBIAN"
        echo "::endgroup::"
        
        echo "::group::Modify package contents"
        # Remove obscure dependency
        if grep -q 'deepin-elf-verify' unpacked/DEBIAN/control; then
          echo "Removing deepin-elf-verify dependency"
          sed -i '/deepin-elf-verify/d' unpacked/DEBIAN/control
        fi
        
        # Make desktop shortcut and icons
        (
            cd "unpacked/opt/apps/${{ env.PACKAGE_NAME }}/entries"
            find applications icons \
                -type f \
                -exec sh -c 'mkdir -p "unpacked/usr/share/$(dirname "{}")"' \; \
                -exec echo 'Symlinking /usr/share/{} to /opt/apps/${{ env.PACKAGE_NAME }}/{}' \; \
                -exec ln -s "/opt/apps/${{ env.PACKAGE_NAME }}/entries/{}" "unpacked/usr/share/{}" \;
        )
        
        # Check if update-desktop-database trigger is present
        if ! grep -q 'update-desktop-database' "unpacked/DEBIAN/postinst"; then
            echo "Adding trigger to update desktop links database"
            echo 'dpkg-trigger update-desktop-database' >> "unpacked/DEBIAN/postinst"
        fi
        echo "::endgroup::"
        
        echo "::group::Prepare output files"
        dpkg -b unpacked "${{ steps.vars.outputs.file }}"
        sha256sum "${{ steps.vars.outputs.file }}" > "${{ steps.vars.outputs.file }}.sha256"
        echo "::endgroup::"

    - name: Upload artifacts
      if: ${{ steps.job-id.result != 'skipped' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.vars.outputs.artifact }}
        path: |
          ${{ steps.vars.outputs.latest }}
          ${{ steps.vars.outputs.latest }}.sha256


  define-upload-matrix:
    runs-on: ubuntu-latest
    needs: handle-package
    outputs:
      versions: ${{ steps.extract.outputs.versions }}
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: List .deb files and extract versions
        id: extract
        run: |
          echo "::group::Extract version numbers"
          versions=()
          mkdir -p release
          latdir="release/${{ env.PERMANENT_RELEASE }}"
          for file in $(find artifacts -name "*.deb"); do
            # Extract the version using basename and cut
            filename=$(basename "$file")
            version="$(echo "$filename" | rev | cut -d'_' -f2 | rev)"
            latest="$latdir/${filename/_${version}_/_latest_}"

            # @TODO: compare versions
            if [ -f "$latest" ]; then
              echo "WARNING: Conflicting files on latest/$filename"
            else
              mkdir -p "$latdir"
              echo "Copying $file to ${{ env.PERMANENT_RELEASE }}"
              cp "$file" "$latest"
              (cd $latdir && sha256sum "$latest" > $latest.sha256)
            fi

            mkdir -p "release/$version"
            echo "Copying $file to $version"
            cp "$file" "release/$version/$filename"
          done
          echo "::endgroup::"

          echo "versions=$(ls | jq -R -s -c 'split("\n")[:-1]')" >> $GITHUB_OUTPUT

      - name: Upload artifacts
        if: ${{ steps.extract.outputs.versions != '[]' }}
        uses: actions/upload-artifact@v4
        with:
          name: release
          path: release
  

  upload-release:
    runs-on: ubuntu-latest
    needs: define-upload-matrix
    name: Release ${{ matrix.version }} packages
    strategy:
      matrix:
        version: ${{ fromJSON(needs.define-upload-matrix.outputs.versions) }}
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: release
          path: release

      - name: Upload release artifacts
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "${{ matrix.version }}"
          files: "release/${{ matrix.version }}/*"
          make_latest: ${{ matrix.version == env.PERMANENT_RELEASE }}
          prerelease: true